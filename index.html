<html>
<head>
    <style>
        html, body{
            margin:0;
        }
    </style>
</head>
<body>

<script src="three.min.js"></script>
<script src="shaders/CopyShader.js"></script>
<script src="shaders/DotScreenShader.js"></script>
<script src="shaders/RGBShiftShader.js"></script>
<script src="shaders/ConvolutionShader.js"></script>

<script src="postprocessing/EffectComposer.js"></script>
<script src="postprocessing/RenderPass.js"></script>
<script src="postprocessing/MaskPass.js"></script>
<script src="postprocessing/ShaderPass.js"></script>
<script src="postprocessing/bloomPass.js"></script>
<script src="jsRocket.min.js"></script>

<script type="application/vertexShader" id="vertexShader">
#ifdef PASS_THROUGH
    varying vec2 vertUV;

    void main(void)
    {
        vertUV = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
#endif

#ifdef REFLECTION_CUBE
    varying vec3 vertNormal;
    varying vec3 vertPosition;

    uniform mat4 reflectionViewMatrix;

    void main(void)
    {
        vertNormal = normalMatrix * normal;
        vec4 vertPos = reflectionViewMatrix * modelMatrix * vec4(position, 1.0);

        vertPosition = vertPos.xyz;
        gl_Position = projectionMatrix * vertPos;
    }
#endif
</script>

<script type="application/fragmentShader" id="fragmentShader">
#ifdef GRID_ISH
    varying vec2 vertUV;

    uniform float time;
    uniform vec2 dir;

    void main(void)
    {
        vec2 uv = (vertUV - 0.5) * 2.;
        uv *= 2.;
        float f = 0.;

        f += clamp(pow(sin(uv.x * 3.145 * 2. + dir.x * time), 15.), 0., 1.);
        f += clamp(pow(sin(uv.y * 3.145 * 2. + dir.y * time), 15.), 0., 1.);
        f += clamp(pow(sin(uv.x * 3.145 * 10. + dir.x * time), 15.), 0., 1.);
        f += clamp(pow(sin(uv.y * 3.145 * 10. + dir.y * time), 15.), 0., 1.);
        //f += clamp(pow(sin(uv.x * 3.145 * 50.), 15.), 0., 1.);
       // f += clamp(pow(sin(uv.y * 3.145 * 50.), 15.), 0., 1.);

        gl_FragColor = f * 0.4 * vec4(1,1,1,1);
    }
#endif

#ifdef REFLECTION_CUBE
    varying vec3 vertNormal;
    varying vec3 vertPosition;

    uniform vec3 pointLightColor[MAX_POINT_LIGHTS];
    uniform vec3 pointLightPosition[MAX_POINT_LIGHTS];
    uniform float pointLightDistance[MAX_POINT_LIGHTS];

    void main(void)
    {
        vec4 addedLights = vec4(0.0,0.0,0.0, 1.0);
        for(int l = 0; l < MAX_POINT_LIGHTS; l++) {
            vec3 lightDirection = normalize(vertPosition
                                  -pointLightPosition[l]);
            addedLights.rgb += clamp(dot(-lightDirection,
                                     normalize(vertNormal)), 0.0, 1.0)
                               * pointLightColor[l];
        }

        gl_FragColor = addedLights * vec4(0.5,0,0.9,0.5);
    }
#endif
    </script>

<script>
    var Demo = (function () {
        var wallEffect = true;
        var mirrorEffect = true;

        var BPM = 120,
            ROWS_PER_BEAT = 4,
            ROW_RATE = BPM / 60 * ROWS_PER_BEAT;
            
        var demoMode = false, //Set to true for preview
            syncDevice = new JSRocket.SyncDevice(),
            row = 0;

        //THREE variables
        var WIDTH = document.body.clientWidth,
            HEIGHT = document.body.clientHeight,
            FOV = 50,
            audio = new Audio(),
            renderer = new THREE.WebGLRenderer(),
            camera = new THREE.PerspectiveCamera(FOV, WIDTH / HEIGHT),
            scene = new THREE.Scene();

        renderer.setSize(WIDTH, HEIGHT);
        scene.add(camera);
        document.body.appendChild(renderer.domElement);

        renderer.autoClear = false;
        var effectBloom = new THREE.BloomPass(1, 25, 5);
        var copyPass = new THREE.ShaderPass(THREE.CopyShader);
        copyPass.renderToScreen = true;
        var composer = new THREE.EffectComposer(renderer);
        composer.addPass(new THREE.RenderPass(scene, camera));
        composer.addPass(effectBloom);
        composer.addPass(copyPass);

        var vertexShaderSrc = document.getElementById( 'vertexShader' ).textContent;
        var fragShaderSrc = document.getElementById( 'fragmentShader' ).textContent;

        var light = new THREE.PointLight(0xffffff, 1.0);
        light.position.set(40.0,40.0,0.0);
        scene.add(light);

        var reflectionShader = new THREE.ShaderMaterial(
        {
            uniforms:
                THREE.UniformsUtils.merge([
                    THREE.UniformsLib['lights'],
                    {
                        reflectionViewMatrix: { type: "m4", value: new THREE.Matrix4() }
                    }
                ]),
            defines: { REFLECTION_CUBE: true },
            vertexShader: vertexShaderSrc,
            fragmentShader: fragShaderSrc,
            lights: true
        });

        var diameterWalls = 100;

        var wallShader = new THREE.ShaderMaterial({
            uniforms: {
                time: { type: "f", value: 1.0 },
                dir: { type: "v2", value: new THREE.Vector3() }
            },
            defines: {PASS_THROUGH: true, GRID_ISH: true},
            vertexShader: vertexShaderSrc,
            fragmentShader: document.getElementById( 'fragmentShader' ).textContent
        });

        var wallLeft = new THREE.Mesh(
                new THREE.BoxGeometry(diameterWalls, diameterWalls, 1, 1, 1, 1), wallShader);
        wallLeft.position.z = -diameterWalls*0.5;

        var wallRight = new THREE.Mesh(
                new THREE.BoxGeometry(diameterWalls, diameterWalls, 1, 1, 1, 1),
                wallShader);
        wallRight.position.z = diameterWalls*0.5;

        var wallBack = new THREE.Mesh(
                new THREE.BoxGeometry(1, diameterWalls, diameterWalls, 1, 1, 1),
                wallShader);
        wallBack.position.x = -diameterWalls*0.5;

        var wallTop = new THREE.Mesh(
                new THREE.BoxGeometry(diameterWalls, diameterWalls, 1, 1, 1, 1),
                wallShader);
        wallTop.rotation.x = THREE.Math.degToRad(90);
        wallTop.rotation.z = THREE.Math.degToRad(90);
        wallTop.position.y = diameterWalls*0.5;

        var wallBot = new THREE.Mesh(
                new THREE.BoxGeometry(diameterWalls, diameterWalls, 1, 1, 1, 1),
                wallShader);
        wallBot.rotation.x = THREE.Math.degToRad(90);
        wallBot.rotation.z = THREE.Math.degToRad(90);
        wallBot.position.y = -diameterWalls*0.5;

        var cube = new THREE.Mesh(
                new THREE.BoxGeometry(10, 10, 10, 1, 1, 1),
                reflectionShader);

        if (demoMode) {
            syncDevice.setConfig({'rocketXML':'cube.rocket'});
            syncDevice.init("demo");
        } else {
            //_syncDevice.setConfig({'socketURL':'ws://192.168.0.100:1338'});
            syncDevice.init();
        }

        syncDevice.on('ready', onSyncReady);
        syncDevice.on('update', onSyncUpdate);
        syncDevice.on('play', onPlay);
        syncDevice.on('pause', onPause);

        var cameraRotation,
            cameraDistance,
            clearR,
            clearG,
            clearB,
            fov,
            dirX,
            dirY,
            mirrorX,
            mirrorY,
            mirrorZ;

        function onSyncReady() {
            
            clearR = syncDevice.getTrack('clearR');
            clearG = syncDevice.getTrack('clearG');
            clearB = syncDevice.getTrack('clearB');
            cameraRotation = syncDevice.getTrack('rotation');
            cameraDistance = syncDevice.getTrack('distance');
            fov = syncDevice.getTrack('FOV');
            dirX = syncDevice.getTrack("dirX");
            dirY = syncDevice.getTrack("dirY");
            mirrorX = syncDevice.getTrack("mirrorX");
            mirrorY = syncDevice.getTrack("mirrorY");
            mirrorZ = syncDevice.getTrack("mirrorZ");

            prepareAudio();
        }

        function prepareAudio() {
            audio.src = "december.mp3";
            audio.load();
            audio.preload = true;
            audio.addEventListener('canplay', onAudioReady);
            document.body.appendChild(audio);
        }
        
        function onAudioReady() {
            if(demoMode) { 
                render();
                audio.play();
            } else {
                audio.pause();
                audio.currentTime = row / ROW_RATE;
            }
        }

        function onSyncUpdate(r) {

            if (!isNaN(r)) {
                row = r;
                audio.currentTime = row / ROW_RATE;
            }
            render();
        }

        var isPlaying = false;
        function onPlay() {
            isPlaying = true;
            audio.play();
            render();
        }

        function onPause() {
            isPlaying = false;
            row = audio.currentTime * ROW_RATE;
            audio.pause();
        }

        function render() {
            if(isPlaying) {
                row = audio.currentTime * ROW_RATE;
                syncDevice.update(row);
                window.requestAnimationFrame(render);
            }

            var time = audio.currentTime;
            wallShader.uniforms.time.value = time;
            wallShader.uniforms.dir.value = new THREE.Vector2(dirX.getValue(row), dirY.getValue(row));

            var rot = (cameraRotation.getValue(row) || 0) / 180 * Math.PI,
                color = new THREE.Color();

            camera.fov = (fov.getValue(row) || FOV);
            camera.updateProjectionMatrix();

            camera.position.x = Math.cos(rot) * (cameraDistance.getValue(row) || 0);
            camera.position.z = Math.sin(rot) * (cameraDistance.getValue(row) || 0);
            camera.lookAt(scene.position);

            color.setRGB((clearR.getValue(row) || 0) / 255,
                        (clearG.getValue(row) || 0) / 255,
                        (clearB.getValue(row) || 0) / 255);
            renderer.setClearColor(color);

            if(wallEffect) {
                scene.add(wallLeft);
                scene.add(wallRight);
                scene.add(wallBack);
                scene.add(wallTop);
                scene.add(wallBot);
            }

            if(mirrorEffect) {
                reflectionShader.uniforms.reflectionViewMatrix.value = camera.matrixWorldInverse;

                cube.position.z = Math.sin(time)*10;
                cube.position.y = Math.sin(time)*10;
                scene.add(cube);
            }
            // Normal
            renderer.clear();
            composer.render(scene, camera);

            // Mirroring
            /*if(mirrorEffect) {
                var reflMat = new THREE.Matrix4();

                var mirX = mirrorX.getValue(row) || 0, mirY = mirrorY.getValue(row)|| 0, mirZ = mirrorZ.getValue(row)|| 0;
                var mir = new THREE.Vector3(mirX, mirY, mirZ);
                mir.normalize();
                reflMat.set(1 - 2*mir.x*mir.x, -2*mir.x*mir.y, -2*mir.x*mir.z, 0,
                            -2*mir.y*mir.x, 1 - 2*mir.y*mir.y, -2*mir.y*mir.z, 0,
                            -2*mir.z*mir.x, -2*mir.z*mir.y, 1 - 2*mir.z*mir.z, 0,
                            0, 0, 0, 1);

                reflectionShader.uniforms.reflectionViewMatrix.value = reflMat.getInverse(reflMat.multiply(camera.matrixWorld));

                renderer.setFaceCulling(THREE.CullFaceNone);
                renderer.autoClearColor = false;
                renderer.autoClearDepth = false;

                renderer.render(scene, camera);

                //renderer.setFaceCulling(THREE.CullFaceBack);
                renderer.autoClearColor = true;
                renderer.autoClearDepth = true;
            }*/
        }
    }());
</script>
</body>